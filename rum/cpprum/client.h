/*
 * Created by Ivan B on 2022/2/6.
 */

#ifndef RUM_CPPRUM_CLIENT_H_
#define RUM_CPPRUM_CLIENT_H_

#include <future>
#include <rum/core/client_base_handler.h>
#include <rum/core/node_base.h>
#include <rum/serialization/serializer.h>

namespace rum{

template <class RepT>
struct FutureResult{
    std::future<Result<RepT>> future;
    // used to cancel a call which unblocks the future get immediately
    CallHandler call_handler;

    inline bool cancel(){ return call_handler.cancel();}
};

// todo ivan. ReqT and RepT could just be in call, would that be better?
template <class ReqT, class RepT>
class Client : public ClientBaseHandler{
  public:
    using SharedPtr = std::shared_ptr<Client<ReqT,RepT>>;
    using UniquePtr = std::unique_ptr<Client<ReqT,RepT>>;

  private:
    SerFunc<ReqT> ser_func_;
    DeserFunc<RepT> ipc_factory_func_;  // deserialize and type convert
    ItcFactoryFunc<RepT> itc_factory_func_;

  public:
    // test constructor
    Client() : ClientBaseHandler(nullptr){};
    Client(ClientBaseHandler &&base, SerFunc<ReqT> ser_func, DeserFunc<RepT> ipc_factory_func,
           ItcFactoryFunc<RepT> itc_factory_func) :
           ClientBaseHandler(std::move(base)), ser_func_(std::move(ser_func)),
           ipc_factory_func_(std::move(ipc_factory_func)), itc_factory_func_(std::move(itc_factory_func)){}

    ~Client() override{
        NodeBase::GlobalNode()->removeClient(*this);
    }

    Result<RepT> callForeground(std::unique_ptr<ReqT> request, unsigned int timeout_ms = 0);

    /**
     * Execute a service call asynchronously
     * Note: returned future is generated by std::async hence will block upon destruction
     * @param request
     * @param timeout_ms Response wait timeout in milliseconds
     * @return FutureResult
     */
    FutureResult<RepT> call(std::unique_ptr<ReqT> request, unsigned int timeout_ms = 0);

    /**
     * Cancel a service call by stopping waiting.
     * @param call_handler CallHandler obtained from call
     * @return whether it is cancelled, false if call already finished
     */
    inline bool cancel(const CallHandler &call_handler) {call_handler.cancel();};
};

///////////////////////////////////////////////////////////////////////////////////////////////////

template<class ReqT, class RepT>
Result<RepT> Client<ReqT, RepT>::callForeground(std::unique_ptr<ReqT> request, unsigned int timeout_ms) {
    using namespace std;
    Result<RepT> result;
    shared_ptr<ReqT> request_sptr = move(request);

    // call intrap
    auto itc_result = callItc(request_sptr, timeout_ms);
    if (itc_result.status!=SrvStatus::NoConnections){
        result.status = itc_result.status;
        result.response = result.status==SrvStatus::OK?
                          const_pointer_cast<RepT>(itc_factory_func_(itc_result.response)) : nullptr;
        return result;
    }

    // call interp
    if (isConnected()){
        auto request_msg = ser_func_(request_sptr);
        auto ipc_result = callIpc(move(request_msg), timeout_ms);
        result.status = ipc_result.status;
        if (result.status ==  SrvStatus::OK){
            auto response_msg = const_pointer_cast<const Message>(ipc_result.response->first);
            result.response = const_pointer_cast<RepT>(ipc_factory_func_(response_msg, ipc_result.response->second));
        } else {
            result.response = nullptr;
        }
    } else{
        result.status = SrvStatus::NoConnections;
    }

    return result;
}

template<class ReqT, class RepT>
FutureResult<RepT> Client<ReqT, RepT>::call(std::unique_ptr<ReqT> request, unsigned int timeout_ms) {
    using namespace std;
    FutureResult<RepT> result;
    shared_ptr<ReqT> request_sptr = move(request);

    // intrap case
    result.call_handler = sendItc(request_sptr);
    if (result.call_handler.getCurrentStatus()!=SrvStatus::NoConnections){
        result.future =  std::async(std::launch::async,
            [call_handler = result.call_handler, timeout_ms, this]() mutable -> Result<RepT>{
                auto itc_result = waitItc(move(call_handler), timeout_ms);
                return {itc_result.status,
                        itc_result.status == SrvStatus::OK?
                        const_pointer_cast<RepT>(itc_factory_func_(itc_result.response)) : nullptr};
            });
        AssertLog(result.future.valid(), "");
        return result;
    }

    // interp case
    if (isConnected()){
        result.call_handler = sendIpc(ser_func_(request_sptr));
        result.future = std::async(std::launch::async,
            [call_handler = result.call_handler, timeout_ms, this]() mutable -> Result<RepT>{
                auto ipc_result = waitIpc(move(call_handler), timeout_ms);
                if (ipc_result.status == SrvStatus::OK){
                    auto response_msg = const_pointer_cast<const Message>(ipc_result.response->first);
                    return {ipc_result.status,
                            const_pointer_cast<RepT>(ipc_factory_func_(response_msg, ipc_result.response->second)) };
                } else{
                    return {ipc_result.status, nullptr};
                }
            });
    } else {
        promise<Result<RepT>> tmp_promise;
        result.future = tmp_promise.get_future();
        tmp_promise.set_value({SrvStatus::NoConnections, nullptr});
    }

    AssertLog(result.future.valid(), "");
    return result;
}

}

#endif //RUM_CPPRUM_CLIENT_H_
