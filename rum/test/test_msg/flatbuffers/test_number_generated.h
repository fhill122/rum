// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TESTNUMBER_RUM_TEST_MSG_H_
#define FLATBUFFERS_GENERATED_TESTNUMBER_RUM_TEST_MSG_H_

#include "flatbuffers/flatbuffers.h"

namespace rum {
namespace test {
namespace msg {

struct Number;
struct NumberBuilder;

struct Number FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NumberBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N1 = 4,
    VT_N2 = 6,
    VT_L1 = 8,
    VT_L2 = 10,
    VT_D1 = 12,
    VT_D2 = 14
  };
  int32_t n1() const {
    return GetField<int32_t>(VT_N1, 0);
  }
  int32_t n2() const {
    return GetField<int32_t>(VT_N2, 0);
  }
  uint64_t l1() const {
    return GetField<uint64_t>(VT_L1, 0);
  }
  uint64_t l2() const {
    return GetField<uint64_t>(VT_L2, 0);
  }
  double d1() const {
    return GetField<double>(VT_D1, 0.0);
  }
  double d2() const {
    return GetField<double>(VT_D2, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_N1) &&
           VerifyField<int32_t>(verifier, VT_N2) &&
           VerifyField<uint64_t>(verifier, VT_L1) &&
           VerifyField<uint64_t>(verifier, VT_L2) &&
           VerifyField<double>(verifier, VT_D1) &&
           VerifyField<double>(verifier, VT_D2) &&
           verifier.EndTable();
  }
};

struct NumberBuilder {
  typedef Number Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_n1(int32_t n1) {
    fbb_.AddElement<int32_t>(Number::VT_N1, n1, 0);
  }
  void add_n2(int32_t n2) {
    fbb_.AddElement<int32_t>(Number::VT_N2, n2, 0);
  }
  void add_l1(uint64_t l1) {
    fbb_.AddElement<uint64_t>(Number::VT_L1, l1, 0);
  }
  void add_l2(uint64_t l2) {
    fbb_.AddElement<uint64_t>(Number::VT_L2, l2, 0);
  }
  void add_d1(double d1) {
    fbb_.AddElement<double>(Number::VT_D1, d1, 0.0);
  }
  void add_d2(double d2) {
    fbb_.AddElement<double>(Number::VT_D2, d2, 0.0);
  }
  explicit NumberBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NumberBuilder &operator=(const NumberBuilder &);
  flatbuffers::Offset<Number> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Number>(end);
    return o;
  }
};

inline flatbuffers::Offset<Number> CreateNumber(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t n1 = 0,
    int32_t n2 = 0,
    uint64_t l1 = 0,
    uint64_t l2 = 0,
    double d1 = 0.0,
    double d2 = 0.0) {
  NumberBuilder builder_(_fbb);
  builder_.add_d2(d2);
  builder_.add_d1(d1);
  builder_.add_l2(l2);
  builder_.add_l1(l1);
  builder_.add_n2(n2);
  builder_.add_n1(n1);
  return builder_.Finish();
}

inline const rum::test::msg::Number *GetNumber(const void *buf) {
  return flatbuffers::GetRoot<rum::test::msg::Number>(buf);
}

inline const rum::test::msg::Number *GetSizePrefixedNumber(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<rum::test::msg::Number>(buf);
}

inline bool VerifyNumberBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<rum::test::msg::Number>(nullptr);
}

inline bool VerifySizePrefixedNumberBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<rum::test::msg::Number>(nullptr);
}

inline void FinishNumberBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rum::test::msg::Number> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNumberBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<rum::test::msg::Number> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace msg
}  // namespace test
}  // namespace rum

#endif  // FLATBUFFERS_GENERATED_TESTNUMBER_RUM_TEST_MSG_H_
